# this file is generated by puppet
#
# ff_gln_gw bird6 base configuration 
#
# This file defines basic templates, base protocols and
# finally pulls in every file suffixed with .conf inside 
# of "/etc/bird6.conf.d/". So if you like to add aditional
# protocols create a file in that directory.

router id <%= @router_id %>;

# The mesh table is the main table which is piped
# into the kernel table. Every mesh specific
# table exports it routes to the mesh table and import
# routes which are not in the mesh specific prefix.
# The mesh_${site} tables exchange routes with the local
# peers from here routes to local subnets are communicated 
# and routes to other communities from icvpn peers in the local
# network are exchanged. 
# 
# If this router is a icvpn peer then routes from the
# icvpn will be exchanged directly with the mesh table.
#              
# icvpn <-> [mesh] <#> [mesh_ffgc,..] <#> local-peers
#             ^--------> [kernel(rtable=42)]
table mesh;
table kernel_main;

# FIXME: Historical, moved fc00::7 to is_freifunk()
# Filter function to check if an IPv6 Route is a ULA.
function is_ula() {
  return (net ~ [ fc00::/7{48,64} ]);
};

# Filter function to check if an IPv6 Route is from
# a Freifunk range.
function is_freifunk() {
  return net ~ [ 2001:0bf7::/32{32,64},        # FÃ¶rderverein freie Netzwerke e.V.
                 2a03:2260::/29{29,64},        # Freifunk Rheinland e.V.
                 fc00::/7{48,64}               # ULA
               ];
}

# Filter function to check if an IPv6 route is from ChaosVPN IP range.
# As of 2017-11-06 there is no v6 range defined, therefore add a stub.
function is_chaos() {
  return (net ~ [ fc00::/128 ]);
};

# Filter function to check if an IPv6 route is from dn42.net.
function is_dn42() {
  return (net ~ [ fd00::/8{48,64} ]);
};

function avoid_martians()
prefix set martians;
{
  # 2001::/23 contains for example 2001:4:112::/48, belonging to AS112
  # so we mustn't filter more specific
  # 3FFE::/16 et 5F00::/8 = formerly 6bone (IPv6 tests)
  martians = [ ::1/128, ::/128, ::ffff:0:0/96+, 100::/64+,
       2001:db8::/32+, 2001::/23, 2001:2::/48+, 64:ff9b::/96{96,128},
       2001:10::/28+, 2002::/17+, fc00::/7, fe80::/10, ff00::/8+,
       3FFE::/16+, 5F00::/8+, ::/0{0,15}, ::/0{49,128} ];

  if net ~ martians then return false;

  return true;
}

function is_global_unicast() {
  return avoid_martians();
}

function ok_for_ebgp_export()
int set reserved_asn;
{
	# http://www.iana.org/assignments/as-numbers/as-numbers.xhtml
	reserved_asn = [
		# 16-bit
		0,                      # Reserved. RFC7607
		23456,                  # AS_TRANS. RFC6793
		64496..64511,           # Reserved for use in documentation and sample code. RFC5398
		64512..65534,           # Reserved for Private Use. RFC6996
		65535,                  # Reserved. RFC7300

		# 32-bit
		65536..65551,           # Reserved for use in documentation and sample code. RFC5398
		65552..131071,          # Reserved.
		4200000000..4294967294, # Reserved for Private Use. [RFC6996]
		4294967295              # Reserved. RFC7300
    ];
    # Avoid too short and too long prefixes
    if (net.len < 16) || (net.len > 48) then {
        #print "Reject: prefix ", net, " too short or too long";
        return false;
    }

    # Remove default route
    #if net = ::/0 then {
    #    #print "Reject: prefix ", net, " defines a default route";
    #    return false;
    #}

    # Avoid reserved networks
    if ! avoid_martians() then {
        #print "Reject: prefix ", net, " is a Martian";
        return false;
    }

    # Just log, not reject ...
    # Avoid bogons. IANA didn't allocate outside of 2000::/3
    # but there are already announces there
    if ! (net.ip ~ 2000::/3) then {
        print "WARN (should reject): prefix ", net, " is a Bogon";
        #return false;
    }

    # AS_PATH too long (max seen in real life = 54)
    if bgp_path.len > 64 then return false;

    # Don't accept if path contains a reserved AS
    # Disabled because it removes legit prefixes
    if bgp_path ~ reserved_asn then {
        print "Reject: prefix ", net, " contains a reserved ASN in it's BGP path ", bgp_path;
        return false;
    }

    if ( (65535, 65281) ~ bgp_community ) then {
        #print "Reject: prefix ", net, " has the no_export community set";
        return false;
    }

    return true;
}

function check_communities_ebgp_export() {
    if ( (65535, 65281) ~ bgp_community ) then {
        print "Reject: prefix ", net, " has the no_export community set";
        return false;
    }
}

# default route
# be careful with importing default routes from arbitrary peers
function is_default() {
  return net ~ [ ::/0 ];
}

# don't use kernel's routes for bird, but export bird's 
# routes to kernel table 42. 
#
# We do not import any routes here, therefore we can be sure
# that no funny routes jump into our waggon.
protocol kernel {
  scan time 20;    # Scan kernel routing table every 20 seconds
  kernel table 42; # routing table for mesh networks
  import none;     # Import no routes
  device routes;   # Export RTS_DEVICE routes as well
  #export all;      # Export all routes
  export filter {
    if (avoid_martians()) then { krt_prefsrc = <%= @loopback_ipv6 %>; }
    accept;
  };
};

# export to kernel main table for local services
protocol kernel {
  table kernel_main;
  scan time 20;
  import none;
  #export all;
  export filter {
    if (source = RTS_BGP && !is_ula()) then { krt_prefsrc = <%= @loopback_ipv6 %>; }
    accept;
  };
  persist;
};

# This pseudo-protocol watches all interface up/down events.
protocol device {
  scan time 10; # Scan interfaces every 10 seconds 
};

# pipe between mesh table and kernel table
# import everything from mesh table into 
# kernel table and export no routes into mesh.
protocol pipe pipe_kernel_mesh {
  peer table mesh;
  import all;
  export none;
};

protocol pipe pipe_kernel_main_mesh {
  table kernel_main;
  peer table mesh;
  import all;
  export none;
};

# template for local route exchange via bgp
template bgp local_mesh {
  import where is_freifunk()<% if @include_chaos == "yes" %> || is_chaos()<% end %><% if @include_dn42 == "yes" %> || is_dn42()<% end %>;
  export where source = RTS_BGP;
  direct;
  next hop self;
};

protocol static loopback {
  table mesh;
  route <%= @loopback_ipv6 %>/128 via "<%= @loopback_if %>";
}

# Include puppet generated rules
